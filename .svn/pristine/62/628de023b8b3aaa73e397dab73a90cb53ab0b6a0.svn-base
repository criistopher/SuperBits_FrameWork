package com.super_bits.modulosSB.SBCore.UtilGeral;

import com.super_bits.modulosSB.SBCore.ConfigGeral.SBCore;
import com.super_bits.modulosSB.SBCore.TratamentoDeErros.ErroSB;
import java.text.Normalizer;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 *
 * @author Salvio
 */
public abstract class UtilSBCoreStrings {

    public static String teste = "teste";
    public static String teste2 = "teste";

    public static String removeCaracteresEspeciais(String param) {
        param = Normalizer.normalize(param, Normalizer.Form.NFD);
        param = param.replaceAll("[^\\p{ASCII}]", "");
        return param;

    }

    public static String makeStrUrlAmigavel(String param) {
        String resposta = removeCaracteresEspeciais(param);
        resposta = resposta.replace(" ", "_");
        resposta = resposta.replace(":", "-");
        return resposta;
    }

    public static List<String> splitMaiuscula(String pParametros) {
        List<String> resp = new ArrayList<String>();
        String nomeTabela = "";
        int i = 0;
        for (char car : pParametros.toCharArray()) {
            if (Character.isUpperCase(car)) {
                if (nomeTabela.equals("") || nomeTabela == null) {
                    nomeTabela = "" + car;
                } else {
                    resp.add(nomeTabela);
                    nomeTabela = "" + car;
                }
            } else {
                nomeTabela = nomeTabela + car;
            }

            if (pParametros.length() == i + 1) {
                resp.add(nomeTabela);
            }
            i++;
        }
        return resp;
    }

    public static String strValorEntreParenteses(String parametro) {

        int inicioIndex = parametro.lastIndexOf("(");

        if (inicioIndex != -1) {

            int fimIndex = parametro.lastIndexOf(")");
            if (fimIndex != -1) {
                return parametro.substring(inicioIndex + 1, fimIndex);
            }

        }

        return null;
    }

    public static String substituiParametrosNomeadosPorInterroga(String parametro) {
        String novosql = parametro;
        novosql = novosql + " ";
        int i = 1;
        while (novosql.indexOf(":") != -1) {
            int idxProximoParenteses = novosql.indexOf(")", novosql.indexOf(":"));
            int idxProximoespaco = novosql.indexOf(" ", novosql.indexOf(":"));;
            int idxfinal = 0;

            if (idxProximoespaco != -1 && idxProximoParenteses != -1) {
                if (idxProximoParenteses < idxProximoespaco) {
                    idxfinal = idxProximoParenteses;
                }
                if (idxProximoespaco < idxProximoParenteses) {
                    idxfinal = idxProximoespaco;
                }
            }
            if (idxProximoParenteses == -1) {
                idxfinal = idxProximoespaco;
            }

            String parametrosql = novosql.substring(novosql.indexOf(":"), idxfinal);

            novosql = novosql.replace(parametrosql, "?" + String.valueOf(i));
            i++;
        }
        return novosql;
    }

    public static Date dtMesBarraAno(String parametro) throws ParseException {
        SimpleDateFormat frm = new SimpleDateFormat("DD/mm/yy");

        return frm.parse(parametro);

    }

    public static boolean compara2StrArrays(String[] ar1, String[] ar2) {
        if (ar1.length != ar2.length) {
            return false;
        }
        int i = 0;
        for (String comp1 : ar1) {
            if (!comp1.equals(ar2[i])) {
                return false;
            }
            i++;
        }
        return true;
    }

    /**
     *
     *
     *
     * @param linha String onde o valor vai ser encontrado
     * @param posicaoInicial Início posição esperada
     * @param posicaoFinal Fim posição esperada
     * @param pQuantidaCaracteres Tamanho esperado (em caso de usar Regex para
     * localizar parte)
     * @param descarte Caso encontre este valor descarte
     * @param confirma Caso não possua esste valor descarte
     * @param regex Caso não passe pela string regex descarte
     * @return
     */
    public static String localizarParte(String linha, int posicaoInicial, int posicaoFinal, Integer pQuantidaCaracteres, String descarte, String confirma, String regex) {

        boolean registroValido = true;
        if (pQuantidaCaracteres == null || pQuantidaCaracteres == 0) {
            pQuantidaCaracteres = posicaoFinal - posicaoInicial;
        }

        String retorno = "";
        if (linha.length() >= posicaoInicial + (posicaoFinal - posicaoInicial)) {
            retorno = linha.substring(posicaoInicial, posicaoFinal);
        }
        if (descarte != null) {
            if (retorno.contains(descarte)) {
                registroValido = false;
            }
        }
        if (confirma != null) {
            if (!retorno.contains(confirma)) {
                registroValido = false;
            }
        }
        if (regex != null) {
            Pattern padrao = Pattern.compile(regex);
            Matcher comp = padrao.matcher(retorno);

            if (!comp.find()) {

                SBCore.RelatarErro(ErroSB.TIPO_ERRO.ALERTA_PROGRAMADOR, "Leitura de SBsubstringPLus ignorada por regex=" + regex + " valor:" + retorno);
                registroValido = false;
            } else {
                if (pQuantidaCaracteres > retorno.length()) {
                    pQuantidaCaracteres = retorno.length();
                }
                try {
                    retorno = retorno.substring(comp.start(), pQuantidaCaracteres);

                } catch (Exception e) {
                    SBCore.RelatarErro(ErroSB.TIPO_ERRO.ALERTA_PROGRAMADOR, "Tamanho do caractér incorreto", e);
                    registroValido = false;
                }
            }

        }
        if (!registroValido) {
            retorno = "";
        }
        return retorno;

    }

    public static String[] getStringsByURL() {
        throw new UnsupportedOperationException("NÃO IMPLEMENTADO");
    }

    public static String[] getStringsByLocalFile() {
        throw new UnsupportedOperationException("NÃO IMPLEMENTADO");
    }

    /**
     *
     * @param pValor String que será formatada
     * @param pCasas número de casas
     * @param digito Digito que ocupará os espacos
     *
     * @return Retorna a string formatada
     */
    public static String getLpad(String pValor, int pCasas, String pDigito) {
        try {

            /*String resultado = String.format("%" + pCasas + "d", Integer.parseInt(pValor));
             resultado = resultado.replace(" ", digito);
             return resultado;
             */
            pValor = String.format("%" + pCasas + "s", pValor).replace(" ", pDigito);

            return pValor;

        } catch (Exception e) {
            SBCore.RelatarErro(ErroSB.TIPO_ERRO.ALERTA_PROGRAMADOR, "Erro ao formatar Lpad", e);
            return pValor;
        }
    }

}
