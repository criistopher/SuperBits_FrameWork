package com.super_bits.modulosSB.SBCore.UtilGeral;

import com.super_bits.modulosSB.SBCore.ConfigGeral.SBCore;
import com.super_bits.modulosSB.SBCore.TratamentoDeErros.ErroSB;
import de.svenjacobs.loremipsum.LoremIpsum;
import java.io.BufferedReader;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.text.Normalizer;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.apache.commons.lang3.text.WordUtils;

/**
 *
 * @author Salvio
 */
public abstract class UtilSBCoreStrings {

    public static String teste = "teste";
    public static String teste2 = "teste";

    public enum TIPO_LOREN {

        PARAGRAFO, PALAVRAS
    }

    public enum TIPO_SINALIZADOR {

        COLCHETE, TAG, ASPAS
    }

    /**
     *
     * @param ptexto
     * @param pTipoBusca
     * @return Uma lista com as palavras encontradas entre os Sinalizadores ex:
     * [teste1] 123 [teste2] retorna uma lista com as palavras teste1 e teste 2
     */
    public static List<String> getListaStringEntreCaracter(String ptexto, TIPO_SINALIZADOR pTipoBusca) {
        switch (pTipoBusca) {
            case ASPAS:
                return getListaStringEntreCaracter(ptexto, '"', '"');
            case TAG:
                return getListaStringEntreCaracter(ptexto, '<', '>');
            case COLCHETE:
                return getListaStringEntreCaracter(ptexto, '[', ']');

        }
        return getListaStringEntreCaracter(ptexto, '"', '"');
    }

    public static List<String> getListaStringEntreCaracter(String texto, char pInicial, char pFinal) {

        char cInicial = pInicial;
        char cFinal = pFinal;
        List<String> resposta = new ArrayList<>();
        String data = "[ffff]  [gggg]";
        String regex = "(" + cInicial + "\\w" + cFinal + ")+";
        Pattern p = Pattern.compile(regex);
        Matcher m = p.matcher(data);

        while (m.find()) {
            resposta.add(m.group());
        }
        return resposta;
    }

    public static String removeCaracteresEspeciais(String param) {
        param = Normalizer.normalize(param, Normalizer.Form.NFD);
        param = param.replaceAll("[^\\p{ASCII}]", "");
        return param;

    }

    public static String makeStrUrlAmigavel(String param) {
        String resposta = removeCaracteresEspeciais(param);
        resposta = resposta.replace(" ", "_");
        resposta = resposta.replace(":", "-");
        return resposta;
    }

    public static List<String> getlistadeLinhas(String pString) {
        String[] linhas = pString.split("[\\r\\n]+");
        List<String> listaLinhas = new ArrayList<>();

        for (String ln : linhas) {
            listaLinhas.add(ln);
        }
        return listaLinhas;

    }

    public static String getStringDaListaComSeparador(List<String> lista, String separador) {
        String resultado = "";
        if (lista == null) {
            return null;
        }
        for (String iten : lista) {
            resultado = resultado + separador + iten;
        }
        return resultado;

    }

    public static List<String> splitMaiuscula(String pParametros) {
        List<String> resp = new ArrayList<String>();
        String nomeTabela = "";
        int i = 0;
        for (char car : pParametros.toCharArray()) {
            if (Character.isUpperCase(car)) {
                if (nomeTabela.equals("") || nomeTabela == null) {
                    nomeTabela = "" + car;
                } else {
                    resp.add(nomeTabela);
                    nomeTabela = "" + car;
                }
            } else {
                nomeTabela = nomeTabela + car;
            }

            if (pParametros.length() == i + 1) {
                resp.add(nomeTabela);
            }
            i++;
        }
        return resp;
    }

    public static String strValorEntreParenteses(String parametro) {

        int inicioIndex = parametro.lastIndexOf("(");

        if (inicioIndex != -1) {

            int fimIndex = parametro.lastIndexOf(")");
            if (fimIndex != -1) {
                return parametro.substring(inicioIndex + 1, fimIndex);
            }

        }

        return null;
    }

    public static String substituiParametrosNomeadosPorInterroga(String parametro) {

        return UtilSBCoreParametrosEmString.substituiParametrosNomeadosPorInterroga(parametro);
    }

    public static Date dtMesBarraAno(String parametro) throws ParseException {
        SimpleDateFormat frm = new SimpleDateFormat("DD/mm/yy");

        return frm.parse(parametro);

    }

    public static boolean compara2StrArrays(String[] ar1, String[] ar2) {
        if (ar1.length != ar2.length) {
            return false;
        }
        int i = 0;
        for (String comp1 : ar1) {
            if (!comp1.equals(ar2[i])) {
                return false;
            }
            i++;
        }
        return true;
    }

    /**
     *
     *
     *
     * @param linha String onde o valor vai ser encontrado
     * @param posicaoInicial Início posição esperada
     * @param posicaoFinal Fim posição esperada
     * @param pQuantidaCaracteres Tamanho esperado (em caso de usar Regex para
     * localizar parte)
     * @param descarte Caso encontre este valor descarte
     * @param confirma Caso não possua esste valor descarte
     * @param regex Caso não passe pela string regex descarte
     * @return
     */
    public static String localizarParte(String linha, int posicaoInicial, int posicaoFinal, Integer pQuantidaCaracteres, String descarte, String confirma, String regex) {

        boolean registroValido = true;
        if (pQuantidaCaracteres == null || pQuantidaCaracteres == 0) {
            pQuantidaCaracteres = posicaoFinal - posicaoInicial;
        }

        String retorno = "";
        if (linha.length() >= posicaoInicial + (posicaoFinal - posicaoInicial)) {
            retorno = linha.substring(posicaoInicial, posicaoFinal);
        }
        if (descarte != null) {
            if (retorno.contains(descarte)) {
                registroValido = false;
            }
        }
        if (confirma != null) {
            if (!retorno.contains(confirma)) {
                registroValido = false;
            }
        }
        if (regex != null) {
            Pattern padrao = Pattern.compile(regex);
            Matcher comp = padrao.matcher(retorno);

            if (!comp.find()) {

                SBCore.RelatarErro(ErroSB.MSG_DEST.PROGRAMADOR, "Leitura de SBsubstringPLus ignorada por regex=" + regex + " valor:" + retorno);
                registroValido = false;
            } else {
                if (pQuantidaCaracteres > retorno.length()) {
                    pQuantidaCaracteres = retorno.length();
                }
                try {
                    retorno = retorno.substring(comp.start(), pQuantidaCaracteres);

                } catch (Exception e) {
                    SBCore.RelatarErro(ErroSB.MSG_DEST.PROGRAMADOR, "Tamanho do caractér incorreto", e);
                    registroValido = false;
                }
            }

        }
        if (!registroValido) {
            retorno = "";
        }
        return retorno;

    }

    public static String[] getStringsByURL() {
        throw new UnsupportedOperationException("NÃO IMPLEMENTADO");
    }

    public static List<String> getStringsByLocalFile() {
        throw new UnsupportedOperationException("NÃO IMPLEMENTADO");
    }

    public static List<String> getStringsByInputStream(InputStream pInputStream) {
        BufferedReader br = null;
        StringBuilder sb = new StringBuilder();
        List<String> resp = new ArrayList<>();
        String line;
        try {

            br = new BufferedReader(new InputStreamReader(pInputStream));
            while ((line = br.readLine()) != null) {
                resp.add(line);

            }

        } catch (IOException e) {
            SBCore.RelatarErro(ErroSB.MSG_DEST.PROGRAMADOR, "Erro obtendo string a partir de arquivo", e);
        } finally {
            if (br != null) {
                try {
                    br.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }

        return resp;
    }

    public static String getStringByInputStream(InputStream pInputStream) {
        BufferedReader br = null;
        StringBuilder sb = new StringBuilder();

        String line;
        try {

            br = new BufferedReader(new InputStreamReader(pInputStream));
            while ((line = br.readLine()) != null) {
                sb.append(line + "\n");
            }

        } catch (IOException e) {
            SBCore.RelatarErro(ErroSB.MSG_DEST.PROGRAMADOR, "Erro obtendo string a partir de arquivo", e);
        } finally {
            if (br != null) {
                try {
                    br.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }

        return sb.toString();
    }

    public static String getStringByOutputStream(OutputStream pOutputStream) {
        ByteArrayOutputStream byte1 = new ByteArrayOutputStream();
        try {
            pOutputStream.write(byte1.toByteArray());
        } catch (IOException ex) {
            Logger.getLogger(UtilSBCoreStrings.class.getName()).log(Level.SEVERE, null, ex);
        }
        return byte1.toString();
    }

    /**
     *
     * @param pValor String que será formatada
     * @param pCasas número de casas
     * @param digito Digito que ocupará os espacos
     *
     * @return Retorna a string formatada
     */
    public static String getLpad(String pValor, int pCasas, String pDigito) {
        try {

            /*String resultado = String.format("%" + pCasas + "d", Integer.parseInt(pValor));
             resultado = resultado.replace(" ", digito);
             return resultado;
             */
            pValor = String.format("%" + pCasas + "s", pValor).replace(" ", pDigito);

            return pValor;

        } catch (Exception e) {
            SBCore.RelatarErro(ErroSB.MSG_DEST.PROGRAMADOR, "Erro ao formatar Lpad", e);
            return pValor;
        }
    }

    /**
     * Gera Loren Ipsum para utilização em textos
     *
     * @param pQuantidade
     * @param pTipoLTipo_loren
     * @return
     */
    public static String GetLorenIpsilum(int pQuantidade, TIPO_LOREN pTipoLTipo_loren) {
        if (pQuantidade == 0) {
            pQuantidade = 3;
        }

        LoremIpsum lorem = new LoremIpsum();
        switch (pTipoLTipo_loren) {
            case PALAVRAS:
                return lorem.getWords(pQuantidade);
            case PARAGRAFO:
                return lorem.getParagraphs(pQuantidade);

        }
        return lorem.getWords(3);

    }

    /**
     * Gera Lorem ipsulum de 3 palavras
     *
     * @param pTipoLTipo_loren
     * @return Loren ipsulum de 3 palavras ou pragrafos de acordo com o campo
     * escolhido
     */
    public static String getLorenIpsilum(TIPO_LOREN pTipoLTipo_loren) {
        return GetLorenIpsilum(0, pTipoLTipo_loren);
    }

    /**
     *
     * Quebra a String adicionando /n a cada X caracteres, sem quebrar palavras
     * ao meio
     *
     * @param pString
     * @param caracteresMaximos
     * @return
     */
    public static String quebrarStringEmLinhas(String pString, int caracteresMaximos) {
        return WordUtils.wrap(pString, caracteresMaximos);

    }

}
