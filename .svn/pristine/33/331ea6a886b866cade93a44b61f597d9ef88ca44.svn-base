package com.super_bits.modulosSB.SBCore.InfoCampos.registro;

import com.super_bits.modulosSB.SBCore.ConfigGeral.SBCore;
import com.super_bits.modulosSB.SBCore.InfoCampos.UtilSBCoreCampoReflexao;
import com.super_bits.modulosSB.SBCore.InfoCampos.anotacoes.InfoCampo;
import com.super_bits.modulosSB.SBCore.InfoCampos.anotacoes.util.ErrorMessages;
import com.super_bits.modulosSB.SBCore.InfoCampos.campo.Campo;
import com.super_bits.modulosSB.SBCore.InfoCampos.campo.CampoEsperado;
import com.super_bits.modulosSB.SBCore.InfoCampos.campo.FabCampos;
import com.super_bits.modulosSB.SBCore.InfoCampos.excecao.ErroDeMapaDeCampos;
import com.super_bits.modulosSB.SBCore.InfoCampos.registro.Interfaces.basico.ItfBeanGenerico;
import com.super_bits.modulosSB.SBCore.InfoCampos.registro.Interfaces.basico.TipoFonteUpload;
import com.super_bits.modulosSB.SBCore.TratamentoDeErros.ErroSB;
import com.super_bits.modulosSB.SBCore.UtilGeral.UtilSBCoreReflexao;
import java.io.Serializable;
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.TreeMap;

/**
 *
 *
 *
 *
 *
 * @author sfurbino
 */
public abstract class ItemGenerico extends Object implements ItfBeanGenerico, Serializable {

    protected CampoMapValores camposEsperados;
    protected List<Campo> camposEncontrados = new ArrayList<>();
    private Map<String, Object> mapaInstanciaCampoByName;

    private Map<Object, Campo> mapaCamposByInstancia;

    private static Class<?> classeModelo;

    public String getTesteParametro(String pteste) {
        if (pteste == null) {
            pteste = "";
        }
        return "o parametro é" + pteste;
    }

    public void makeValorCampoByName() {

        Map<String, Object> resp = new TreeMap<>();

        Class<?> current = this.getClass();

        for (Field field : current.getDeclaredFields()) {
            field.setAccessible(true);
            if (!Modifier.isStatic(field.getModifiers())) {
                if (!resp.containsKey(field.getName())) {
                    try {
                        resp.put(field.getName(), field.get(this));
                    } catch (IllegalArgumentException e) {

                        SBCore.RelatarErro(ErroSB.MSG_DEST.PROGRAMADOR, "Arqumento ilegal validando campos ", e);
                    } catch (IllegalAccessException e) {

                        SBCore.RelatarErro(ErroSB.MSG_DEST.PROGRAMADOR, "Acesso ilegal validando campos ", e);
                    }
                }
            }

        }
        mapaInstanciaCampoByName = resp;
    }

    private void aplicaValores() {
        Map<String, Field> campos = analyze(this);
        for (String nomeCampo : campos.keySet()) {
            try {
                campos.get(nomeCampo).setAccessible(true);
                campos.get(nomeCampo)
                        .set(this, mapaInstanciaCampoByName.get(nomeCampo));

            } catch (IllegalArgumentException | IllegalAccessException e) {

                SBCore.RelatarErro(ErroSB.MSG_DEST.PROGRAMADOR, "Erro aplicando valor padrão do campo", e);
            }
        }
    }

    /**
     * cria um mapa com todos os campos da classe.
     *
     * Aqueles encontrados encontrados com a Anotação @InfoCampo, tem suas
     * configurações personalizadas
     *
     * Aqueles sem esta anotação são configurados de maneira padrão de acordo
     * com o tipo
     *
     */
    public void MakeCamposEncontrados() {
        // TODO Para cada Filed adciona um Campo
        Map<String, Field> mapEncontrados = analyze(this);
        camposEncontrados.clear();
        for (String teste : mapEncontrados.keySet()) {

            Field campoEncontrado = mapEncontrados.get(teste);
            //String tipoc = campoEncontrado.getType().getSimpleName();
            //String nome = campoEncontrado.getName();
            // campoEncontrado.getDeclaredAnnotations();
            // campoEncontrado.getName();
            InfoCampo anotacaoInfoCampo = campoEncontrado
                    .getAnnotation(InfoCampo.class);

            campoEncontrado.setAccessible(true);
            if (anotacaoInfoCampo != null) {

                Campo novoCampo = anotacaoInfoCampo.tipo().getRegistro();
                camposEncontrados.add(novoCampo);
                // caso não tenha a anotação:
            } else {

                Campo novoCampo = FabCampos.getTipoPadraoByClasse(campoEncontrado.getType()).getRegistro(campoEncontrado);
                camposEncontrados.add(novoCampo);

            }

        }

    }

    protected static Map<String, Field> analyze(Object object) {
        try {
            if (object == null) {
                throw new NullPointerException("Erro obtendo análalise de propriedades da classe");
            }

            Map<String, Field> map = new TreeMap<>();

            Class<?> current = object.getClass();

            for (Field field : current.getDeclaredFields()) {
                if (!Modifier.isStatic(field.getModifiers())) {
                    if (!map.containsKey(field.getName())) {
                        map.put(field.getName(), field);
                    }
                }

            }

            return map;
        } catch (Throwable e) {
            SBCore.RelatarErro(ErroSB.MSG_DEST.PROGRAMADOR, "Erro analizando proriedades da classe", e);
            return new TreeMap<>();
        }
    }

    public void copiaDados(Object dados) {
        if (dados == null) {
            return;
        }
        Map<String, Field> fromFields = analyze(dados);
        Map<String, Field> toFields = analyze(this);
        fromFields.keySet().retainAll(toFields.keySet());

        for (Entry<String, Field> fromFieldEntry : fromFields.entrySet()) {
            final String name = fromFieldEntry.getKey();
            final Field sourceField = fromFieldEntry.getValue();
            final Field targetField = toFields.get(name);
            if (targetField.getType().isAssignableFrom(sourceField.getType())) {
                sourceField.setAccessible(true);
                if (Modifier.isFinal(targetField.getModifiers())) {
                    continue;
                }
                targetField.setAccessible(true);
                try {
                    targetField.set(this, sourceField.get(dados));
                } catch (IllegalAccessException e) {
                    throw new IllegalStateException("Can't access field!");
                }
            }
        }
    }

    protected ItemGenerico() {
        super();
        this.camposEsperados = new CampoMapValores();
        classeModelo = this.getClass();
        UtilSBCoreReflexao.instanciarListas(this);
    }

    /**
     *
     * Retorna o Campo de acordo com a Anotação
     *
     * @param pNomedaAnotacao
     * @return
     */
    protected Field getCampoByAnotacao(FabCampos pNomedaAnotacao) {

        Field campo = UtilSBCoreCampoReflexao.getSBCampobyTipoCampo(classeModelo, pNomedaAnotacao);
        if (campo == null) {
            return null;
        }
        return campo;

    }

    /**
     *
     * Cria um campo Esperado que não é obrigatório
     *
     * @param name
     * @return
     * @deprecated
     */
    @Deprecated
    protected void adcionaCampoEsperado(CampoEsperado pCampo) {
        adcionaCampoEsperado(pCampo, false);
    }

    /**
     *
     * Quando um Objeto generico é criado, é nescessário especificar quais os
     * campos devem ser anotados ao extender a classe exemplo: Uma classe
     * abstrata que implementa ItfBeanGenerico deve ter em seu constructor
     *
     * adcionaCampoEsperado(new CampoEsperado(FabCampos.NOME_CURTO),true);
     * adcionaCampoEsperado(new CampoEsperado(FabCampos.ID),true);
     *
     * Desta forma sempre que a Classe for instanciada e estes campos NãO
     * tiverem sido anotados o sistema irá disparar um erro do tipo PARATUDO
     *
     * @param pCampo Campo que deve ser instanciado com o FabCampo
     * @param pObrigatorio (Especifica que a anotação de um campo deste tipo é
     * obrigatória na classe).
     */
    protected void adcionaCampoEsperado(CampoEsperado pCampo, boolean pObrigatorio) {

        try {
            Field campo;

            campo = getCampoByAnotacao(pCampo.getTipoCampo());
            pCampo.setAnotacaoObrigatoria(pObrigatorio);
            if (campo != null) {
                pCampo.setCampoReflex(campo);
                pCampo.setFoiAnotado(true);

            } else {
                pCampo.setFoiAnotado(false);
                if (pObrigatorio) {
                    throw new UnsupportedOperationException("Campo " + pCampo.getTipoCampo() + " obrigatório não foi implementado na classe " + this.getClass().getSimpleName());
                }
            }
            camposEsperados.AdcionaCampo(pCampo);
        } catch (Throwable e) {
            SBCore.RelatarErro(ErroSB.MSG_DEST.PROGRAMADOR, "Erro adicionando validando campos do Objeto (Atenção, nas proximas versões este erro irá gerar um PARATUDO", e);
        }

    }

    /**
     *
     * Retorna o Valor da propriedade de acordo com a anotação
     *
     * @param tipoCampo Tipo do campo procurado
     * @return Valor da propriedade pojo anotada com o campo procurado
     */
    protected Object getValorByTipoCampoEsperado(FabCampos tipoCampo) {
        CampoEsperado campoPadrao = camposEsperados.getCampo(tipoCampo);

        classeModelo = this.getClass();
        if (campoPadrao.getFoiAnotado()) {
            Field campoReflecao;
            try {

                campoReflecao = campoPadrao.getCampoReflex();

                campoReflecao.setAccessible(true);
                // System.out.println(campoReflecao.toString());
                Object valor;
                try {
                    String tipoDeValor = campoReflecao.getType().getName();
                    if (tipoDeValor.equals("java.lang.String")) {
                        valor = (String) campoReflecao.get(this);
                    } else {

                        // System.out.println("TTTTIIIPOOOO diferente de String:"+campoReflecao.getType().getName());
                        if (campoReflecao.getType().getName().equals("int")) {
                            // System.out.println("TTTTIIIPOOOO int");
                            valor = (Integer) campoReflecao.get(this);
                        } else if (campoReflecao.getType().getName()
                                .equals("java.lang.Double")
                                || campoReflecao.getType().getName()
                                .equals("double")) {
                            valor = (Double) campoReflecao.get(this);
                        } else if (campoReflecao.getType().getSimpleName()
                                .equals("Date")) {
                            valor = ((Date) campoReflecao.get(this)).toString();

                        } else {

                            valor = campoReflecao.get(this).toString();
                        }
                    }

                    if (valor == null || valor.toString().equals("")) {
                        return campoPadrao.getValorPadrao();
                    } else {
                        return valor;
                    }
                } catch (IllegalArgumentException | IllegalAccessException e) {
                    SBCore.RelatarErro(ErroSB.MSG_DEST.PROGRAMADOR, "erro obtendo valor de campo ", e);
                }

            } catch (SecurityException e) {

                SBCore.RelatarErro(ErroSB.MSG_DEST.PROGRAMADOR, "erro obtendo valor de campo ", e);
            }
        }

        if (campoPadrao.getAnotacaoObrigatoria()) {

            try {
                throw new ErroDeMapaDeCampos(String.format(
                        ErrorMessages.CAMPO_ANOTACAO_OBRIGATORIO,
                        campoPadrao.getTipoCampo()));
            } catch (ErroDeMapaDeCampos e) {

                SBCore.RelatarErro(ErroSB.MSG_DEST.PROGRAMADOR, "Erro gerenciando mapa de campos para validação", e);
            }
        }

        return campoPadrao.getValorPadrao();

    }

    /**
     *
     * @return This.class
     */
    @Deprecated
    public static Class<?> getClasseModelo() {

        return classeModelo;
    }

    public List<Campo> getCamposEncontrados() {
        if (camposEncontrados == null || camposEncontrados.isEmpty()) {
            MakeCamposEncontrados();
        }
        return camposEncontrados;
    }

    /**
     *
     * Retorna um mapa de objetos instanciados pelo nomeDaPropriedade
     *
     * @return Instancia da propriedade pelo nome
     */
    public Map<String, Object> getValorCampoByName() {
        try {
            if (mapaInstanciaCampoByName == null) {
                makeValorCampoByName();
            }

            return mapaInstanciaCampoByName;
        } finally {
            aplicaValores();
        }
    }

    public Campo getCampoByInstancia(Object pInstancia) {
        try {
            if (mapaInstanciaCampoByName == null) {
                //makeValorCampoByName();
            }

            return mapaCamposByInstancia.get(pInstancia);
        } finally {
            aplicaValores();
        }
    }

    public void setValorCampoByName(Map<String, Object> valorCampoByName) {
        this.mapaInstanciaCampoByName = valorCampoByName;
    }

    @Override
    public Field getCampo(FabCampos pInfoCampo) {
        return UtilSBCoreCampoReflexao.getSBCampobyTipoCampo(this.getClass(), pInfoCampo);
    }

    @Override
    public String getNomeCampo(FabCampos pInfocampo) {
        return UtilSBCoreCampoReflexao.getSBCampobyTipoCampo(this.getClass(), pInfocampo).getName();
    }

    @Override
    public void uploadFoto(TipoFonteUpload pTipo, Object pRecurso) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

}
